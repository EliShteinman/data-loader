# אפליקציית FastAPI: מדריך לארכיטקטורת הקוד

מסמך זה מספק סקירה מקיפה של מבנה קוד הפייתון, תפקידו של כל קובץ, וכיצד הם משתלבים יחד. המדריך מציג את הארכיטקטורה הסופית תוך השוואה לפתרון הבסיסי שהיה עונה על דרישות המקוריות של הפרויקט, כדי להסביר את הסיבות מאחורי כל שדרוג.

## הקדמה: מהדרישה המקורית לאפליקציית Production

הפרויקט התחיל מדרישה בסיסית: להקים שירות API עם נקודת קצה אחת, `GET /data`, שתחזיר את כל המידע מטבלה. כדי לעמוד בסטנדרטים של פרויקט ברמת Production, הרחבנו את הדרישה הזו לארכיטקטורה מלאה. הסעיפים הבאים מפרטים את מבנה הקוד הסופי, תוך ציון השינויים המרכזיים מהגישה הפשוטה.

---

## פירוט מבנה הקוד הסופי

### `main.py` - נקודת הכניסה והרכבת האפליקציה

**תפקיד נוכחי:**
הקובץ הראשי שממנו מופעלת האפליקציה. תפקידו הוא כמו "דבק" המחבר את כל חלקי המערכת. הוא אחראי על יצירת אפליקציית FastAPI, ניהול מחזור החיים שלה (`lifespan`), וחיבור הראוטרים השונים.

**ההתפתחות מהגרסה הבסיסית:**
*   **במקור:** קובץ זה היה מכיל גם את הלוגיקה של נקודות הקצה וגם את יצירת אובייקט ה-`DataLoader`.
*   **כיום:** הוא נקי מלוגיקה עסקית. הוא רק "מרכיב" את האפליקציה. הוא מייבא את ה-`data_loader` המשותף מקובץ `dependencies.py` וטוען את נקודות הקצה של ה-CRUD מקובץ `crud/items.py`. הוא עדיין מכיל את נקודת הקצה המקורית `/data` למטרות תאימות.

### `core/dependencies.py` - ניהול תלויות מרכזי

**תפקיד נוכחי:**
קובץ זה הוא חדש לחלוטין ולא היה קיים בגרסה הבסיסית. הוא נוצר כדי לפתור בעיה ארכיטקטונית של ייבוא מעגלי (Circular Import).
תפקידו הוא לרכז את יצירת האובייקטים המשותפים (תלויות) שהאפליקציה צריכה. הוא קורא את התצורה ממשתני הסביבה ויוצר **מופע אחד ויחיד (Singleton)** של הקלאס `DataLoader`.

**ההתפתחות מהגרסה הבסיסית:**
*   **במקור:** יצירת ה-`DataLoader` התבצעה ישירות ב-`main.py`.
*   **כיום:** היצירה עברה לכאן כדי שכל חלקי האפליקציה יוכלו לייבא את אותו אובייקט ממקור מרכזי וניטרלי, ובכך נמנע ייבוא מעגלי.

### `dal.py` - שכבת הגישה לנתונים (DAL)

**תפקיד נוכחי:**
זהו הלב של התקשורת מול מסד הנתונים. כל הלוגיקה הקשורה ל-SQL נמצאת אך ורק בקובץ זה.

**ההתפתחות מהגרסה הבסיסית:**
*   **במקור (שימוש בחיבור יחיד):** הקלאס החזיק משתנה `self.connection` שהיה חיבור בודד למסד הנתונים. כל פעולה השתמשה באותו החיבור. גישה זו יוצרת צוואר בקבוק תחת עומס.
    ```python
    # דוגמה מהגישה המקורית:
    class DataLoader_Basic:
        def __init__(self, ...):
            self.connection = None
        def connect(self):
            self.connection = mysql.connector.connect(...)
        def get_all_data(self):
            cursor = self.connection.cursor()
            # ...
    ```
*   **כיום (שימוש ב-Connection Pool):** הקלאס שודרג לנהל **מאגר של חיבורים (Connection Pool)**. במקום חיבור יחיד, הוא מנהל מאגר של חיבורים מוכנים מראש. כל מתודה (כמו `get_all_data`, `create_item`) מבקשת חיבור פנוי מהמאגר, משתמשת בו, **ומחזירה אותו למאגר** בסיום. גישה זו משפרת דרמטית את הביצועים והסקיילביליות.
    ```python
    # דוגמה מהגישה הנוכחית:
    from mysql.connector import pooling
    class DataLoader:
        def __init__(self, ...):
            self.pool = None
        def connect(self):
            self.pool = pooling.MySQLConnectionPool(...)
        def get_all_data(self):
            connection = self.pool.get_connection()
            try:
                # ...
            finally:
                connection.close() # מחזיר את החיבור למאגר
    ```
בנוסף, המתודות הורחבו כדי לתמוך בכל פעולות ה-CRUD.

### `crud/items.py` - שכבת ה-API (הראוטר)

**תפקיד נוכחי:**
קובץ זה חדש לחלוטין ולא היה קיים בגרסה הבסיסית. הוא מגדיר את נקודות הקצה של ה-API לניהול "פריטים" (`items`) באמצעות `APIRouter`.

**ההתפתחות מהגרסה הבסיסית:**
*   **במקור:** נקודת הקצה היחידה (`GET /data`) הייתה מוגדרת ישירות ב-`main.py`.
*   **כיום:** כדי לתמוך ב-CRUD מלא בצורה מאורגנת, כל נקודות הקצה הרלוונטיות (`POST /`, `GET /{id}` וכו') מוגדרות כאן, תחת הקידומת `/items`. זה הופך את הקוד למודולרי וקל להרחבה בעתיד.

### `models.py` - מודלי הנתונים

**תפקיד נוכחי:**
קובץ זה גם הוא חדש. הוא מגדיר את "השפה המשותפת" של ה-API באמצעות Pydantic.
-   **`ItemBase`:** מודל בסיסי עם שדות משותפים.
-   **`ItemCreate`:** מודל לקלט (מה שהמשתמש שולח).
-   **`Item`:** מודל לפלט (מה שהשרת מחזיר).

**ההתפתחות מהגרסה הבסיסית:**
*   **במקור:** לא היה צורך במודלים מורכבים כי נקודת הקצה היחידה החזירה ישירות את מה שהגיע ממסד הנתונים.
*   **כיום:** שימוש במודלים מאפשר ל-FastAPI לספק ולידציה אוטומטית של קלט ופלט, ותיעוד API אינטראקטיבי עשיר, מה שהופך את ה-API לחסין וקל יותר לשימוש.