# תיעוד מניפסטים של Kubernetes/OpenShift

מדריך זה מסביר את התפקיד של כל אחד מקבצי ה-YAML בתיקייה זו, ואת האופן שבו הם מרכיבים יחד את תשתית האפליקציה.

הפריסה מורכבת משני רכיבים עיקריים:
1.  **תשתית מסד הנתונים (MySQL):** כוללת תצורה, סודות, אחסון קבוע, פריסה ושירות רשת.
2.  **תשתית האפליקציה (FastAPI):** כוללת פריסה, שירות רשת וחשיפה לעולם החיצון.

הקבצים ממוספרים לפי סדר הפריסה ההגיוני שלהם.

---

## תשתית מסד הנתונים (MySQL)

### `00-mysql-configmap.yaml`
*   **סוג:** `ConfigMap`
*   **מטרה:** אחראי על ניהול **תצורה שאינה סודית** עבור מסד הנתונים. כשיטה מומלצת, אנו מפרידים מידע תצורה רגיל (כמו שם מסד הנתונים והמשתמש) ממידע רגיש (סיסמאות).
*   **שדות מרכזיים:**
    *   `data`: מכיל את צמדי המפתח-ערך של התצורה, כמו `MYSQL_DATABASE` ו-`MYSQL_USER`.

### `01-mysql-secret.yaml`
*   **סוג:** `Secret`
*   **מטרה:** מיועד לאחסון **מידע רגיש** בלבד, כמו סיסמאות. OpenShift מנהל את הסודות בצורה מאובטחת יותר מאשר ConfigMaps.
*   **שדות מרכזיים:**
    *   `stringData`: מאפשר לנו להזין את הסודות כטקסט רגיל (string), ו-OpenShift ידאג לקודד אותם אוטומטית ל-base64. זה נוח יותר מאשר שדה ה-`data` הרגיל.
    *   מכיל את `MYSQL_ROOT_PASSWORD` ו-`MYSQL_PASSWORD`.

### `02-mysql-pvc.yaml`
*   **סוג:** `PersistentVolumeClaim` (PVC)
*   **מטרה:** זוהי "בקשה" רשמית מ-OpenShift לקבל "דיסק קשיח" וירטואלי (Persistent Volume). אחסון זה הוא **קבוע** (persistent), כלומר המידע שנשמר עליו ישרוד גם אם הקונטיינר של מסד הנתונים יקרוס או יופעל מחדש.
*   **שדות מרכזיים:**
    *   `accessModes: ReadWriteOnce`: מגדיר שרק Pod אחד יכול "להתחבר" לכונן הזה ולכתוב אליו בכל רגע נתון.
    *   `resources.requests.storage`: מגדיר את גודל האחסון המבוקש (במקרה זה, 1Gi).

### `03-mysql-deployment.yaml`
*   **סוג:** `Deployment`
*   **מטרה:** זהו ה-"שרטוט" (blueprint) הראשי להרצת מסד הנתונים. הוא מגדיר ל-OpenShift איזה אימג' להריץ, כמה עותקים (replicas), ואת כל התצורה הנדרשת.
*   **חיבורים לרכיבים אחרים:**
    *   **`envFrom`:** טוען את כל המשתנים מה-`ConfigMap` וה-`Secret` שיצרנו קודם ישירות כמשתני סביבה לתוך הקונטיינר.
    *   **`volumes` ו-`volumeMounts`:** מחברים את ה-`PVC` שיצרנו לתיקייה ` /var/lib/mysql` בתוך הקונטיינר, שם MySQL שומר את הנתונים שלו.
    *   **`probes`:** בדיקות `liveness` ו-`readiness` שמאפשרות ל-OpenShift לדעת אם הקונטיינר בריא ומוכן לקבל חיבורים.
    *   **`resources` (ניהול משאבים):** זהו בלוק קריטי ליציבות בסביבת פרודקשן. הוא מגדיר את "חוזה המשאבים" בין ה-Pod לבין הקלאסטר.
        *   **`requests`:** כמות המשאבים המינימלית שה-Pod **מבקש ומובטח לו לקבל**. OpenShift ישבץ את ה-Pod רק על שרת (Node) שיש לו מספיק משאבים פנויים כדי לספק בקשה זו.
        *   **`limits`:** כמות המשאבים המקסימלית שה-Pod **רשאי לצרוך**. אם הוא ינסה לעבור את המגבלה, הוא יווסת (במקרה של CPU) או ייהרג ויופעל מחדש (במקרה של זיכרון - OOMKilled). זה מונע מ-Pod אחד להפיל את כל השרת.

### `04-mysql-service.yaml`
*   **סוג:** `Service`
*   **מטרה:** יוצר **כתובת רשת פנימית, יציבה וקבועה** (למשל, `mysql-db-service`) עבור מסד הנתונים. אפליקציית ה-API תתחבר לשם הזה, וה-Service ידאג לנתב את התעבורה ל-Pod הנכון של MySQL, גם אם ה-Pod יקבל כתובת IP חדשה.
*   **שדות מרכזיים:**
    *   `selector`: הלב של ה-Service. הוא מגדיר אילו Pods שייכים לשירות זה, על בסיס התאמה לתוויות (`labels`) שלהם.

---

## תשתית האפליקציה (FastAPI)

### `05-fastapi-deployment.yaml`
*   **סוג:** `Deployment`
*   **מטרה:** השרטוט להרצת אפליקציית ה-API שלנו.
*   **חיבורים לרכיבים אחרים:**
    *   **`image`:** מציין את האימג' שיצרנו ודחפנו ל-Docker Hub.
    *   **`env`:** מזריק את פרטי החיבור למסד הנתונים כמשתני סביבה. שימו לב שהוא משתמש בשם ה-`Service` של MySQL (`mysql-db-service`) ובערכים מה-`ConfigMap` וה-`Secret` של MySQL.
    *   **`probes`:** משתמש בנקודת הקצה `/` של ה-API שלנו כדי לבדוק שהשירות חי ומוכן.
    *   **`resources`:** בדומה ל-Deployment של MySQL, מגדיר את הבקשות והמגבלות על CPU וזיכרון עבור שירות ה-API, כדי להבטיח ריצה יציבה.

### `06-fastapi-service.yaml`
*   **סוג:** `Service`
*   **מטרה:** בדיוק כמו ה-Service של MySQL, הוא מספק כתובת רשת פנימית ויציבה עבור ה-Pods של ה-API. ה-`Route` יפנה תעבורה לשירות הזה.

### `07-fastapi-route.yaml`
*   **סוג:** `Route` (אובייקט ספציפי ל-OpenShift)
*   **מטרה:** השער של האפליקציה לעולם החיצון. הוא מקבל כתובת URL ציבורית ומנתב את התעבורה הנכנסת מהאינטרנט אל ה-`Service` של ה-API.
*   **שדות מרכזיים:**
    *   `to.name`: מציין לאיזה `Service` פנימי לנתב את התעבורה.
    *   `tls.termination: edge`: מגדיר שה-`Route` יטפל בכל הצפנת ה-HTTPS, כך שהאפליקציה שלנו לא צריכה להתעסק עם תעודות SSL.

---

## תרשים זרימה של הארכיטקטורה

```
[ משתמש באינטרנט ]
        |
        v (HTTPS/443)
[ Route: mysql-api-route ]
        |
        v
[ Service: mysql-api-service ]
        |
        v (מנתב ל-Pod עם תווית מתאימה)
[ Pod (FastAPI) ] ------------------------------------
        |                                            |
        v (מתחבר ל-'mysql-db-service')                |
[ Service: mysql-db-service ]                        |
        |                                            | (טוען משתנים מ:)
        v (מנתב ל-Pod עם תווית מתאימה)                |
[ Pod (MySQL) ]                                      |
        |                                            |
        +-- משתמש ב- --> [ Secret: mysql-db-credentials ]
        |
        +-- משתמש ב- --> [ ConfigMap: mysql-db-config ]
        |
        +-- שומר נתונים ב- --> [ PVC: mysql-db-pvc ] --> [ Persistent Volume ]
```