# אפליקציית FastAPI: ארכיטקטורה והתפתחות

מסמך זה מתאר את הארכיטקטורה הפנימית של קוד הפייתון, החל מהפתרון הבסיסי שעונה על דרישות הפרויקט המקוריות, ועד לשדרוגים שהופכים אותו לאפליקציה חסינה וסקיילבילית ברמת פרודקשן.

## שלב א': הפתרון הבסיסי (עמידה בדרישות הפרויקט)

דרישת הליבה של הפרויקט הייתה ליצור שירות API שמסוגל למשוך את כל הרשומות מטבלת `data` במסד נתונים של MySQL. הפתרון הראשוני והפשוט ביותר מורכב משני קבצים עיקריים:

1.  **`main.py`:** נקודת הכניסה של האפליקרובאינטרנט.
2.  **`data_loader.py`:** שכבת גישה לנתונים (DAL) המנהלת חיבור יחיד למסד הנתונים.

### ארכיטקטורה בסיסית

-   **`main.py`:** יוצר את אפליקציית ה-FastAPI, קורא את פרטי החיבור מהסביבה, יוצר מופע של `DataLoader`, ומגדיר נקודת קצה יחידה: `GET /data`.
-   **`DataLoader` (גרסה בסיסית):** הקלאס מכיל משתנה `self.connection` שמחזיק **חיבור בודד** למסד הנתונים. המתודה `connect()` יוצרת את החיבור הזה כשהאפליקציה עולה, והמתודה `get_all_data()` משתמשת בו כדי לשלוף את הנתונים.

#### דוגמת קוד: `DataLoader` בסיסי
```python
# זהו הקוד המקורי שהיה עונה על הדרישות הבסיסיות
import mysql.connector
from mysql.connector import Error

class DataLoader_Basic:
    def __init__(self, host, user, password, database):
        self.connection = None
        # ... (שאר פרטי התצורה)

    def connect(self):
        # יוצר חיבור יחיד ומאחסן אותו ב-self.connection
        self.connection = mysql.connector.connect(...)

    def get_all_data(self):
        # משתמש ב-self.connection הקיים כדי להריץ שאילתה
        cursor = self.connection.cursor(dictionary=True)
        cursor.execute("SELECT * FROM data")
        result = cursor.fetchall()
        cursor.close()
        return result
```

### הבעיות בגישה הבסיסית

הפתרון הזה עובד, אך הוא סובל משתי בעיות מרכזיות בסביבה מרובת משתמשים:
1.  **צוואר בקבוק (Bottleneck):** כל בקשות ה-API שמגיעות במקביל "עומדות בתור" כדי להשתמש באותו חיבור יחיד למסד הנתונים. אם בקשה אחת איטית, כל השאר מתעכבות.
2.  **חוסר פונקציונליות:** ה-API תומך רק בקריאת כל הנתונים, ואינו מאפשר ניהול מלא של המידע (יצירה, עדכון, מחיקה).

---

## שלב ב': שדרוג לארכיטקטורת Production

כדי לפתור את הבעיות הללו, שדרגנו את האפליקציה לארכיטקטורה מודולרית וסקיילבילית.

### שדרוג 1: מחיבור יחיד למאגר חיבורים (Connection Pool)

במקום חיבור בודד, `DataLoader` המשודרג מנהל **מאגר (Pool) של חיבורים** מוכנים מראש.

#### מהו Connection Pool?
תחשוב על זה כמו בנק עם מספר פקידים במקום פקיד אחד. כשהאפליקציה עולה, היא פותחת מספר חיבורים (למשל, 5) ומחזיקה אותם "בהמתנה".
-   כשמגיעה בקשת API, היא "שואלת" חיבור פנוי מהמאגר. זו פעולה מהירה מאוד.
-   בסיום הבקשה, היא לא סוגרת את החיבור, אלא **מחזירה אותו למאגר**, שם הוא ממתין לבקשה הבאה.

#### יתרונות:
-   **ביצועים:** אין צורך לבזבז זמן על פתיחת חיבור חדש לכל בקשה.
-   **סקיילביליות:** האפליקציה יכולה לטפל במספר בקשות במקביל, כל אחת עם החיבור שלה.
-   **אמינות:** המאגר מנהל חיבורים שנכשלו ומחליף אותם אוטומטית.

#### דוגמת קוד: `DataLoader` משודרג עם Pool
```python
# services/data_loader/dal.py (הגרסה הנוכחית)
from mysql.connector import pooling

class DataLoader:
    def __init__(self, ...):
        self.pool = None # במקום self.connection

    def connect(self):
        # יוצר מאגר של חיבורים במקום חיבור יחיד
        self.pool = pooling.MySQLConnectionPool(pool_size=5, ...)

    def get_all_data(self):
        # מבקש חיבור פנוי מהמאגר
        connection = self.pool.get_connection()
        try:
            # ... מבצע את הפעולה
        finally:
            # מחזיר את החיבור למאגר לשימוש חוזר
            connection.close()
```

### שדרוג 2: הרחבה ל-CRUD מלא עם APIRouter

כדי להוסיף פונקציונליות CRUD (`Create`, `Read`, `Update`, `Delete`) מבלי "ללכלך" את הקובץ הראשי (`main.py`), השתמשנו ב-`APIRouter` של FastAPI.

-   **`routers/items.py`:** קובץ זה מכיל "מיני-אפליקציה" המוקדשת כולה לניהול "פריטים". הוא מגדיר את כל נקודות הקצה של ה-CRUD (כמו `POST /items/`, `GET /items/{id}`).
-   **`models.py`:** קובץ זה מגדיר את "צורות" הנתונים באמצעות Pydantic, מה שמבטיח ולידציה אוטומטית ותיעוד API איכותי.
-   **`main.py`:** בקובץ הראשי, אנו פשוט "מחברים" את הראוטר החדש לאפליקציה הראשית באמצעות `app.include_router(items.router)`.

#### התוצאה: ארכיטקטורה מודולרית ונקייה

-   **הקוד המקורי נשאר:** נקודת הקצה `GET /data` עדיין קיימת ב-`main.py` ועונה על דרישת הפרויקט המקורית.
-   **הפונקציונליות החדשה מופרדת:** כל הלוגיקה של ה-CRUD נמצאת במקום נפרד ומאורגן.
-   **האפליקציה גמישה:** קל מאוד להוסיף בעתיד עוד "ראוטרים" עבור סוגי נתונים אחרים (למשל, `users`, `products`) בלי לגעת בקוד הקיים.

### זרימת נתונים לדוגמה: בקשת `POST /items/`

1.  **בקשת HTTP:** לקוח שולח בקשת `POST` עם גוף JSON לכתובת `/items/`.
2.  **FastAPI ו-Pydantic:**
    -   FastAPI מנתב את הבקשה לפונקציה `create_new_item` בקובץ `routers/items.py`.
    -   Pydantic מאמת את ה-JSON מול המודל `ItemCreate`.
3.  **שכבת ה-API (`routers/items.py`):**
    -   הפונקציה קוראת למתודה `data_loader.create_item(item)`.
4.  **שכבת הגישה לנתונים (`data_loader.py`):**
    -   המתודה `create_item` מבקשת חיבור מה-Pool.
    -   היא מריצה את שאילתת ה-`INSERT`.
    -   היא מחזירה את החיבור ל-Pool.
5.  **תגובת HTTP:**
    -   שכבת ה-API מקבלת את התוצאה ושולחת תגובת `201 Created` בחזרה ללקוח.